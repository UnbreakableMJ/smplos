#!/bin/bash
# smplOS: List and delete managed web apps created with launch-webapp.
# Supports deleting a single web app or all of them.

set -euo pipefail

APPS_DIR="$HOME/.local/share/applications"
PROFILES_DIR="$HOME/.local/share/webapps"
ICONS_DIR="$HOME/.local/share/icons/hicolor/256x256/apps"

declare -a WEBAPP_NAMES=()
declare -a WEBAPP_FILES=()
declare -a WEBAPP_SLUGS=()

refresh_cache() {
  update-desktop-database "$APPS_DIR" 2>/dev/null || true
  command -v rebuild-app-cache &>/dev/null && rebuild-app-cache 2>/dev/null || true
}

scan_webapps() {
  WEBAPP_NAMES=()
  WEBAPP_FILES=()
  WEBAPP_SLUGS=()

  shopt -s nullglob
  for f in "$APPS_DIR"/*.desktop; do
    local exec_line name slug
    exec_line=$(grep -m1 '^Exec=' "$f" | cut -d= -f2- || true)
    [[ "$exec_line" == *launch-webapp* ]] || continue

    name=$(grep -m1 '^Name=' "$f" | cut -d= -f2- || true)
    slug=""

    if [[ "$exec_line" =~ --name[[:space:]]+\"([^\"]+)\" ]]; then
      slug="${BASH_REMATCH[1]}"
    elif [[ "$exec_line" =~ --name[[:space:]]+([^[:space:]]+) ]]; then
      slug="${BASH_REMATCH[1]}"
    fi

    [[ -z "$slug" ]] && slug="$(basename "$f" .desktop)"
    [[ -z "$name" ]] && name="$slug"

    WEBAPP_NAMES+=("$name")
    WEBAPP_FILES+=("$f")
    WEBAPP_SLUGS+=("$slug")
  done
  shopt -u nullglob
}

delete_one() {
  local idx="$1"
  local file="${WEBAPP_FILES[$idx]}"
  local slug="${WEBAPP_SLUGS[$idx]}"
  local name="${WEBAPP_NAMES[$idx]}"

  rm -f "$file"
  rm -rf "$PROFILES_DIR/$slug"
  rm -f "$ICONS_DIR/webapp-$slug.png"
  rm -f "$ICONS_DIR/webapp-$slug.svg"

  refresh_cache
  echo "Deleted: $name"
}

delete_all() {
  local i
  for i in "${!WEBAPP_FILES[@]}"; do
    rm -f "${WEBAPP_FILES[$i]}"
    rm -rf "$PROFILES_DIR/${WEBAPP_SLUGS[$i]}"
    rm -f "$ICONS_DIR/webapp-${WEBAPP_SLUGS[$i]}.png"
    rm -f "$ICONS_DIR/webapp-${WEBAPP_SLUGS[$i]}.svg"
  done

  refresh_cache
  echo "Deleted all web apps (${#WEBAPP_FILES[@]})."
}

delete_selected_indices() {
  local deleted=0
  local idx file slug
  for idx in "$@"; do
    [[ "$idx" =~ ^[0-9]+$ ]] || continue
    [[ "$idx" -ge 0 && "$idx" -lt "${#WEBAPP_FILES[@]}" ]] || continue
    file="${WEBAPP_FILES[$idx]}"
    slug="${WEBAPP_SLUGS[$idx]}"
    rm -f "$file"
    rm -rf "$PROFILES_DIR/$slug"
    rm -f "$ICONS_DIR/webapp-$slug.png"
    rm -f "$ICONS_DIR/webapp-$slug.svg"
    deleted=$((deleted + 1))
  done

  if [[ "$deleted" -gt 0 ]]; then
    refresh_cache
    echo "Deleted selected web apps ($deleted)."
  fi
}

header() {
  echo ""
  echo "Web App Manager"
  echo "-------------"
  echo "Manage launchers created with create-webapp."
  echo "This removes launcher entries, per-app profile data, and generated icons."
  echo ""
}

wait_refresh_or_quit() {
  local k1 k2 k3
  echo "Press Enter to refresh list, or Esc to quit."
  IFS= read -rsn1 k1 || return 0
  if [[ "$k1" == $'\x1b' ]]; then
    IFS= read -rsn1 -t 0.05 k2 || true
    IFS= read -rsn1 -t 0.05 k3 || true
    exit 0
  fi
}

confirm_delete_key() {
  local message="$1"
  local k1 rest

  echo "$message"
  echo "Press Delete to confirm. Press any other key to cancel."

  # Ignore any stray newlines that may remain after gum selection.
  while IFS= read -rsn1 k1; do
    [[ "$k1" == $'\n' || "$k1" == $'\r' ]] && continue
    break
  done

  # Delete key on many terminals emits ESC [ 3 ~ (possibly with modifiers).
  if [[ "$k1" == $'\x1b' ]]; then
    rest=""
    # Slurp the rest of the escape sequence (if any)
    while IFS= read -rsn1 -t 0.02 k1; do
      rest+="$k1"
    done

    # Plain Escape -> quit manager
    [[ -z "$rest" ]] && return 130

    # Accept Delete variants: [3~, [3;2~, [3;5~, etc.
    [[ "$rest" =~ ^\[3([;][0-9]+)?~$ ]] && return 0

    # Other escape sequences: cancel
    return 1
  fi

  # Some terminals/keymaps send DEL as 0x7f directly.
  [[ "$k1" == $'\x7f' ]]
}

choose_with_gum() {
  local options=()
  local i label selected picks idx

  for i in "${!WEBAPP_NAMES[@]}"; do
    label=$(printf "%02d) %s [%s]" "$i" "${WEBAPP_NAMES[$i]}" "${WEBAPP_SLUGS[$i]}")
    options+=("$label")
  done

  selected=$(printf '%s\n' "${options[@]}" | gum choose --no-limit --header "Select web apps (Space to mark, Enter to confirm)") || return $?
  [[ -z "$selected" ]] && return 1

  picks=()
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    idx=$(printf '%s' "$line" | sed -E 's/^([0-9]+)\).*/\1/')
    [[ -n "$idx" ]] && picks+=("$idx")
  done <<< "$selected"

  [[ ${#picks[@]} -eq 0 ]] && return 1
  if confirm_delete_key "Delete ${#picks[@]} selected web app(s)? This cannot be undone."; then
    delete_selected_indices "${picks[@]}"
  else
    rc=$?
    [[ "$rc" -eq 130 ]] && return 130
  fi
}

choose_with_fzf() {
  local options=()
  local i label out line picks idx

  for i in "${!WEBAPP_NAMES[@]}"; do
    label=$(printf "%02d) %s [%s]" "$i" "${WEBAPP_NAMES[$i]}" "${WEBAPP_SLUGS[$i]}")
    options+=("$label")
  done

  # Del = accept (delete marked items), Enter/Esc = abort (cancel).
  # No --expect needed; del:accept overrides the default delete-char binding.
  out=$(printf '%s\n' "${options[@]}" \
    | fzf -m --layout=reverse --height=95% --no-input \
      --header "Tab/Space: mark | Del: delete marked | Ctrl-A: all | Esc: quit" \
      --bind 'space:toggle+down,tab:toggle+down,shift-tab:toggle+up' \
      --bind 'ctrl-a:select-all,ctrl-d:deselect-all' \
      --bind 'del:accept,enter:abort') || return 130

  picks=()
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    idx=$(printf '%s' "$line" | sed -E 's/^([0-9]+)\).*/\1/')
    [[ -n "$idx" ]] && picks+=("$idx")
  done <<< "$out"

  [[ ${#picks[@]} -eq 0 ]] && return 1
  delete_selected_indices "${picks[@]}"
}

choose_one_fallback() {
  local idx
  echo "Select a web app to delete:"
  select idx_label in "${WEBAPP_NAMES[@]}" "Back"; do
    if [[ "$REPLY" -ge 1 && "$REPLY" -le "${#WEBAPP_NAMES[@]}" ]]; then
      idx=$((REPLY - 1))
      read -r -p "Delete '${WEBAPP_NAMES[$idx]}'? (y/N): " ans
      [[ "$ans" =~ ^[Yy]$ ]] && delete_one "$idx"
      break
    elif [[ "$idx_label" == "Back" ]]; then
      break
    fi
  done
}

main_loop() {
  while true; do
    scan_webapps
    header

    if [[ ${#WEBAPP_FILES[@]} -eq 0 ]]; then
      echo "No managed web apps found in $APPS_DIR"
      echo ""
      exit 0
    fi

    echo "Found ${#WEBAPP_FILES[@]} web app(s)."
    echo ""

    if command -v fzf &>/dev/null; then
      choose_with_fzf || {
        rc=$?
        [[ "$rc" -eq 130 ]] && exit 0
      }
      wait_refresh_or_quit
    elif command -v gum &>/dev/null; then
      choose_with_gum || {
        rc=$?
        [[ "$rc" -eq 130 ]] && exit 0
      }
      wait_refresh_or_quit
    else
      echo "1) Delete one web app"
      echo "2) Delete ALL web apps"
      echo "3) Refresh list"
      echo "4) Quit"
      read -r -p "Choice [1-4]: " choice
      case "$choice" in
        1) choose_one_fallback ;;
        2)
          read -r -p "Delete ALL ${#WEBAPP_FILES[@]} web apps? (y/N): " ans
          [[ "$ans" =~ ^[Yy]$ ]] && delete_all
          ;;
        3) ;;
        4) exit 0 ;;
      esac
      echo ""
      read -r -p "Press Enter to continue..." _
    fi
  done
}

main_loop
