#!/bin/bash

# smplOS Configurator - gum-based installation wizard
# Step-based wizard with back/retry support (ESC never quits)

source "$SMPLOS_INSTALL/helpers/all.sh"

step() {
  clear_logo
  echo
  gum style "$1"
  echo
}

notice() {
  clear_logo
  echo
  gum spin --spinner "pulse" --title "$1" -- sleep "${2:-2}"
  echo
}

# ============================================================================
# STEP FUNCTIONS - each returns 0 on success, 1 to signal "go back"
# ============================================================================

# STEP 1: KEYBOARD LAYOUT
step_keyboard() {
  step "Let's setup your machine..."
  keyboards=$'Azerbaijani|azerty
Belarusian|by
Belgian|be-latin1
Bosnian|ba
Bulgarian|bg-cp1251
Croatian|croat
Czech|cz
Danish|dk-latin1
Dutch|nl
English (UK)|uk
English (US)|us
English (US, Dvorak)|dvorak
Estonian|et
Finnish|fi
French|fr
French (Canada)|cf
French (Switzerland)|fr_CH
Georgian|ge
German|de
German (Switzerland)|de_CH-latin1
Greek|gr
Hebrew|il
Hungarian|hu
Icelandic|is-latin1
Irish|ie
Italian|it
Japanese|jp106
Kazakh|kazakh
Khmer (Cambodia)|khmer
Kyrgyz|kyrgyz
Lao|la-latin1
Latvian|lv
Lithuanian|lt
Macedonian|mk-utf
Norwegian|no-latin1
Polish|pl
Portuguese|pt-latin1
Portuguese (Brazil)|br-abnt2
Romanian|ro
Russian|ru
Serbian|sr-latin
Slovak|sk-qwertz
Slovenian|slovene
Spanish|es
Spanish (Latin American)|la-latin1
Swedish|sv-latin1
Tajik|tj_alt-UTF8
Turkish|trq
Ukrainian|ua'
  local choice
  choice=$(printf '%s\n' "$keyboards" | cut -d'|' -f1 | gum choose --height 10 --selected "English (US)" --header "Select keyboard layout (ESC to go back)") || return 1
  keyboard=$(printf '%s\n' "$keyboards" | awk -F'|' -v c="$choice" '$1==c{print $2; exit}')

  # Only attempt to load keyboard layout if we're on a real console
  if [[ $(tty 2>/dev/null) == "/dev/tty"* ]]; then
    loadkeys "$keyboard" 2>/dev/null
  fi
  return 0
}

# Console keymap -> XKB layout mapping (for setting the primary XKB layout)
keymap_to_xkb() {
  case "$1" in
    us|dvorak)          echo "us" ;;
    uk)                 echo "gb" ;;
    de|de_CH-latin1)    echo "de" ;;
    fr|fr_CH)           echo "fr" ;;
    es)                 echo "es" ;;
    it)                 echo "it" ;;
    pt-latin1)          echo "pt" ;;
    br-abnt2)           echo "br" ;;
    ru)                 echo "ru" ;;
    ua)                 echo "ua" ;;
    pl)                 echo "pl" ;;
    cz)                 echo "cz" ;;
    sk-qwertz)          echo "sk" ;;
    hu)                 echo "hu" ;;
    ro)                 echo "ro" ;;
    bg-cp1251)          echo "bg" ;;
    hr|croat)           echo "hr" ;;
    sr-latin)           echo "rs" ;;
    slovene)            echo "si" ;;
    ba)                 echo "ba" ;;
    mk-utf)             echo "mk" ;;
    nl)                 echo "nl" ;;
    be-latin1)          echo "be" ;;
    dk-latin1)          echo "dk" ;;
    no-latin1)          echo "no" ;;
    sv-latin1)          echo "se" ;;
    fi)                 echo "fi" ;;
    is-latin1)          echo "is" ;;
    et)                 echo "ee" ;;
    lt)                 echo "lt" ;;
    lv)                 echo "lv" ;;
    gr)                 echo "gr" ;;
    tr*|trq)            echo "tr" ;;
    il)                 echo "il" ;;
    jp106)              echo "jp" ;;
    cf)                 echo "ca" ;;
    ie)                 echo "ie" ;;
    ge)                 echo "ge" ;;
    azerty)             echo "az" ;;
    by)                 echo "by" ;;
    kazakh)             echo "kz" ;;
    kyrgyz)             echo "kg" ;;
    la-latin1)          echo "latam" ;;
    khmer)              echo "kh" ;;
    tj_alt-UTF8)        echo "tj" ;;
    *)                  echo "us" ;;
  esac
}

# STEP 1b: EXTRA KEYBOARD LAYOUT (optional)
step_extra_layout() {
  step "Add an extra keyboard layout? (optional)"

  if ! gum confirm --default=false --affirmative "Yes, add another layout" --negative "No, skip" "Would you like to add a second keyboard layout?"; then
    extra_layout=""
    extra_variant=""
    return 0
  fi

  # Build list: popular layouts with variants first, then all XKB layouts
  local layouts
  layouts=$(cat <<'LAYOUTS'
Arabic|ara|
Belarusian|by|
Bulgarian|bg|
Bulgarian (phonetic)|bg|phonetic
Chinese|cn|
Croatian|hr|
Czech|cz|
Danish|dk|
Dutch|nl|
English (UK)|gb|
English (US)|us|
English (US, Colemak)|us|colemak
English (US, Dvorak)|us|dvorak
English (US, intl. with dead keys)|us|altgr-intl
Estonian|ee|
Finnish|fi|
French|fr|
French (AZERTY)|fr|azerty
French (BEPO)|fr|bepo
French (Canada)|ca|
Georgian|ge|
German|de|
German (Switzerland)|ch|
Greek|gr|
Hebrew|il|
Hungarian|hu|
Icelandic|is|
Irish|ie|
Italian|it|
Japanese|jp|
Kazakh|kz|
Korean|kr|
Kyrgyz|kg|
Latvian|lv|
Lithuanian|lt|
Macedonian|mk|
Mongolian|mn|
Norwegian|no|
Persian|ir|
Polish|pl|
Portuguese|pt|
Portuguese (Brazil)|br|
Romanian|ro|
Russian|ru|
Russian (phonetic)|ru|phonetic
Russian (phonetic, YAZHERTY)|ru|phonetic_YAZHERTY
Russian (phonetic, Windows)|ru|phonetic_winkeys
Serbian|rs|
Slovak|sk|
Slovenian|si|
Spanish|es|
Spanish (Latin American)|latam|
Swedish|se|
Thai|th|
Turkish|tr|
Ukrainian|ua|
Ukrainian (phonetic)|ua|phonetic
Uzbek|uz|
Vietnamese|vn|
LAYOUTS
)

  local choice
  choice=$(printf '%s\n' "$layouts" | cut -d'|' -f1 | gum filter --height 12 --header "Pick a layout (type to search, ESC to go back)") || return 1

  if [[ -z "$choice" ]]; then
    extra_layout=""
    extra_variant=""
    return 0
  fi

  extra_layout=$(printf '%s\n' "$layouts" | awk -F'|' -v c="$choice" '$1==c{print $2; exit}')
  extra_variant=$(printf '%s\n' "$layouts" | awk -F'|' -v c="$choice" '$1==c{print $3; exit}')
  return 0
}

# STEP 2: USERNAME
step_username() {
  step "Let's setup your user account..."

  while true; do
    local input
    input=$(gum input --placeholder "Alphanumeric without spaces (like admin)" --placeholder.foreground="#006600" --prompt.foreground="#00ff00" --prompt "Username> ") || return 1

    if [[ "$input" =~ ^[a-z_][a-z0-9_-]*[$]?$ ]]; then
      username="$input"
      return 0
    else
      notice "Username must be alphanumeric with no spaces" 1
      step "Let's setup your user account..."
    fi
  done
}

# STEP 3: PASSWORD
step_password() {
  step "Choose a password (used for user + root + encryption)..."

  while true; do
    local pw pw_confirm
    pw=$(gum input --placeholder "Used for user + root + encryption" --placeholder.foreground="#006600" --prompt.foreground="#00ff00" --password --prompt "Password> ") || return 1
    pw_confirm=$(gum input --placeholder "Must match the password you just typed" --placeholder.foreground="#006600" --prompt.foreground="#00ff00" --password --prompt "Confirm> ") || return 1

    if [[ -n "$pw" && "$pw" == "$pw_confirm" ]]; then
      password="$pw"
      password_hash=$(printf '%s' "$password" | openssl passwd -6 -stdin)
      return 0
    elif [[ -z "$pw" ]]; then
      notice "Your password can't be blank!" 1
      step "Choose a password (used for user + root + encryption)..."
    else
      notice "Passwords didn't match!" 1
      step "Choose a password (used for user + root + encryption)..."
    fi
  done
}

# STEP 4: HOSTNAME
step_hostname() {
  step "Choose a hostname..."

  while true; do
    local input
    input=$(gum input --placeholder "Alphanumeric without spaces (or return for 'smplos')" --placeholder.foreground="#006600" --prompt.foreground="#00ff00" --prompt "Hostname> " --value "${hostname:-}") || return 1

    if [[ "$input" =~ ^[A-Za-z_][A-Za-z0-9_-]*\$?$ ]]; then
      hostname="$input"
      return 0
    elif [[ -z "$input" ]]; then
      hostname="smplos"
      return 0
    else
      notice "Hostname must be alphanumeric using dashes or underscores but no spaces" 1
      step "Choose a hostname..."
    fi
  done
}

# STEP 5: TIMEZONE
step_timezone() {
  step "Select your timezone..."

  local tz
  tz=$(timedatectl list-timezones | gum filter --height 10 --header "Timezone (start typing to search, ESC to go back)") || return 1
  timezone="$tz"
  return 0
}

# STEP 6: REVIEW
step_review() {
  step "Review your settings..."

  echo -e "Field,Value
Username,$username
Password,$(printf "%${#password}s" | tr ' ' '*')
Hostname,$hostname
Timezone,$timezone
Keyboard,$keyboard
Extra layout,${extra_layout:+${extra_layout}${extra_variant:+ ($extra_variant)}}${extra_layout:-[None]}" |
    gum table -s "," -p | sed "s/^/${PADDING_LEFT_SPACES}/"

  echo
  if gum confirm --negative "No, start over" "Does this look right?"; then
    return 0
  else
    return 1
  fi
}

# STEP 7: DISK SELECTION

get_disk_info() {
  local device="$1"
  local size model

  size=$(lsblk -dno SIZE "$device" 2>/dev/null)
  model=$(lsblk -dno MODEL "$device" 2>/dev/null | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')

  local display="$device"
  [[ -n "$size" ]] && display="$display ($size)"
  [[ -n "$model" ]] && display="$display - $model"

  echo "$display"
}

step_disk() {
  step "Let's select where to install smplOS..."

  # Don't offer the install media as an option
  local exclude_disk
  exclude_disk=$(findmnt -no SOURCE /run/archiso/bootmnt 2>/dev/null || true)

  local available_disks
  available_disks=$(
    lsblk -dpno NAME,TYPE |
      awk '$2=="disk"{print $1}' |
      grep -E '/dev/(sd|hd|vd|nvme|mmcblk|xv)' |
      { if [[ -n "$exclude_disk" ]]; then grep -Fvx "$exclude_disk"; else cat; fi; }
  )

  local disk_options=""
  while IFS= read -r device; do
    if [[ -n "$device" ]]; then
      local disk_info
      disk_info=$(get_disk_info "$device")
      disk_options="$disk_options$disk_info"$'\n'
    fi
  done <<<"$available_disks"

  local selected_display
  selected_display=$(echo "$disk_options" | gum choose --header "Select install disk (ESC to go back)") || return 1
  disk=$(echo "$selected_display" | awk '{print $1}')
  return 0
}

# STEP 8: DISK CONFIRMATION
step_disk_confirm() {
  step "Confirm disk selection..."

  gum style "Everything will be overwritten. There is no recovery possible."
  echo
  if gum confirm --affirmative "Yes, format disk" --negative "No, go back" "Confirm overwriting ${disk}"; then
    return 0
  else
    return 1
  fi
}

# ============================================================================
# WIZARD ENGINE - walks through steps, ESC goes back, never quits
# ============================================================================

# Define the ordered list of steps
steps=(
  step_keyboard
  step_extra_layout
  step_username
  step_password
  step_hostname
  step_timezone
  step_review
  step_disk
  step_disk_confirm
)

current_step=0
total_steps=${#steps[@]}

while (( current_step < total_steps )); do
  if ${steps[$current_step]}; then
    # Success - move forward
    current_step=$(( current_step + 1 ))
  else
    # ESC / go back / "start over"
    if [[ "${steps[$current_step]}" == "step_review" ]]; then
      # "No, start over" sends back to keyboard
      current_step=0
    elif (( current_step > 0 )); then
      current_step=$(( current_step - 1 ))
    fi
    # If already at step 0, just re-show it
  fi
done

clear

# Save keyboard layout choices for install.sh
echo "$(keymap_to_xkb "$keyboard")" >user_primary_xkb.txt
echo "${extra_layout:-}" >user_extra_layout.txt
echo "${extra_variant:-}" >user_extra_variant.txt

# Escape username and password for safe inclusion in JSON
password_escaped=$(printf '%s' "$password" | jq -Rsa)
password_hash_escaped=$(printf '%s' "$password_hash" | jq -Rsa)
username_escaped=$(printf '%s' "$username" | jq -Rsa)

cat <<-_EOF_ >user_credentials.json
{
    "encryption_password": $password_escaped,
    "root_enc_password": $password_hash_escaped,
    "users": [
        {
            "enc_password": $password_hash_escaped,
            "groups": [],
            "sudo": true,
            "username": $username_escaped
        }
    ]
}
_EOF_

# Setup partition layout
disk_size=$(lsblk -bdno SIZE "$disk")
mib=$((1024 * 1024))
gib=$((mib * 1024))
disk_size_in_mib=$((disk_size / mib * mib))

gpt_backup_reserve=$((mib))
boot_partition_start=$((mib))
boot_partition_size=$((2 * gib))

main_partition_start=$((boot_partition_size + boot_partition_start))
main_partition_size=$((disk_size_in_mib - main_partition_start - gpt_backup_reserve))

# Detect T2 Mac and set appropriate kernel
if lspci -nn 2>/dev/null | grep -q "106b:180[12]"; then
  kernel_choice="linux-t2"
else
  kernel_choice="linux-zen"
fi

# Build package list dynamically from packages.txt
# These are ISO-only packages that should NOT go to the installed system
iso_only_packages=(
  syslinux mtools
  memtest86+ memtest86+-efi
  limine edk2-shell
  intel-ucode amd-ucode
  archinstall
  openssl
)

build_packages_json() {
  local packages_file="/root/smplos/packages.txt"
  local packages_extra_file="/root/smplos/packages-extra.txt"
  local first=true

  # Read base packages
  if [[ -f "$packages_file" ]]; then
    while IFS= read -r line; do
      # Skip comments and blank lines
      [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
      local pkg
      pkg=$(echo "$line" | xargs)  # trim whitespace
      [[ -z "$pkg" ]] && continue

      # Skip ISO-only packages
      local skip=false
      for iso_pkg in "${iso_only_packages[@]}"; do
        if [[ "$pkg" == "$iso_pkg" ]]; then
          skip=true
          break
        fi
      done
      $skip && continue

      # Output JSON array element
      if $first; then
        printf '        "%s"' "$pkg"
        first=false
      else
        printf ',\n        "%s"' "$pkg"
      fi
    done < "$packages_file"
  fi

  # Read edition-specific extra packages
  if [[ -f "$packages_extra_file" && -s "$packages_extra_file" ]]; then
    while IFS= read -r line; do
      [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
      local pkg
      pkg=$(echo "$line" | xargs)
      [[ -z "$pkg" ]] && continue

      if $first; then
        printf '        "%s"' "$pkg"
        first=false
      else
        printf ',\n        "%s"' "$pkg"
      fi
    done < "$packages_extra_file"
  fi

  echo  # trailing newline
}

packages_json=$(build_packages_json)

cat <<-_EOF_ >user_configuration.json
{
    "app_config": null,
    "archinstall-language": "English",
    "auth_config": {},
    "audio_config": { "audio": "pipewire" },
    "bootloader": "Grub",
    "custom_commands": [],
    "disk_config": {
        "btrfs_options": { 
          "snapshot_config": {
            "type": "Snapper"
          }
        },
        "config_type": "default_layout",
        "device_modifications": [
            {
                "device": "$disk",
                "partitions": [
                    {
                        "btrfs": [],
                        "dev_path": null,
                        "flags": [ "boot", "esp" ],
                        "fs_type": "fat32",
                        "mount_options": [],
                        "mountpoint": "/boot",
                        "obj_id": "ea21d3f2-82bb-49cc-ab5d-6f81ae94e18d",
                        "size": {
                            "sector_size": { "unit": "B", "value": 512 },
                            "unit": "B",
                            "value": $boot_partition_size
                        },
                        "start": {
                            "sector_size": { "unit": "B", "value": 512 },
                            "unit": "B",
                            "value": $boot_partition_start
                        },
                        "status": "create",
                        "type": "primary"
                    },
                    {
                        "btrfs": [
                            { "mountpoint": "/", "name": "@" },
                            { "mountpoint": "/home", "name": "@home" },
                            { "mountpoint": "/var/log", "name": "@log" },
                            { "mountpoint": "/var/cache/pacman/pkg", "name": "@pkg" }
                        ],
                        "dev_path": null,
                        "flags": [],
                        "fs_type": "btrfs",
                        "mount_options": [ "compress=zstd" ],
                        "mountpoint": null,
                        "obj_id": "8c2c2b92-1070-455d-b76a-56263bab24aa",
                        "size": {
                            "sector_size": { "unit": "B", "value": 512 },
                            "unit": "B",
                            "value": $main_partition_size
                        },
                        "start": {
                            "sector_size": { "unit": "B", "value": 512 },
                            "unit": "B",
                            "value": $main_partition_start
                        },
                        "status": "create",
                        "type": "primary"
                    }
                ],
                "wipe": true
            }
        ],
        "disk_encryption": {
            "encryption_type": "luks",
            "lvm_volumes": [],
            "iter_time": 2000,
            "partitions": [ "8c2c2b92-1070-455d-b76a-56263bab24aa" ],
            "encryption_password": $password_escaped
        }
    },
    "hostname": "$hostname",
    "kernels": [ "$kernel_choice" ],
    "network_config": { "type": "nm" },
    "ntp": true,
    "parallel_downloads": 8,
    "script": null,
    "services": [],
    "swap": true,
    "timezone": "$timezone",
    "locale_config": {
        "kb_layout": "$keyboard",
        "sys_enc": "UTF-8",
        "sys_lang": "en_US.UTF-8"
    },
    "mirror_config": {
        "custom_repositories": [],
        "custom_servers": [
            {"url": "https://geo.mirror.pkgbuild.com/\$repo/os/\$arch"},
            {"url": "https://mirror.rackspace.com/archlinux/\$repo/os/\$arch"}
        ],
        "mirror_regions": {},
        "optional_repositories": []
    },
    "packages": [
$packages_json    ],
    "profile_config": {
        "gfx_driver": null,
        "greeter": null,
        "profile": {}
    },
    "version": "3.0.9"
}
_EOF_

if [[ $1 == "dry" ]]; then
  echo -e "User Configuration:"
  cat user_configuration.json

  echo -e "\n\nUser Credentials:"
  cat user_credentials.json

  echo -e "\n\nPrimary XKB: $(cat user_primary_xkb.txt) / Extra Layout: $(cat user_extra_layout.txt) / Variant: $(cat user_extra_variant.txt)"

  rm user_configuration.json user_credentials.json user_primary_xkb.txt user_extra_layout.txt user_extra_variant.txt
fi
