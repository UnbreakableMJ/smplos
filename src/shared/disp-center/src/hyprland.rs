use serde::Deserialize;
use std::process::Command;

use crate::backend::DisplayBackend;
use crate::monitor::{Monitor, MonitorConfig, MonitorMode};

pub struct HyprlandBackend;

impl HyprlandBackend {
    pub fn new() -> Self {
        Self
    }

    fn hyprctl(&self, args: &[&str]) -> Result<String, String> {
        let output = Command::new("hyprctl")
            .args(args)
            .output()
            .map_err(|e| format!("Failed to run hyprctl: {e}"))?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Err(format!("hyprctl {} failed: {stderr}", args.join(" ")));
        }

        Ok(String::from_utf8_lossy(&output.stdout).to_string())
    }
}

/// Raw JSON shape from `hyprctl monitors -j`.
#[derive(Debug, Deserialize)]
struct HyprMonitor {
    id: i32,
    name: String,
    description: String,
    width: i32,
    height: i32,
    #[serde(rename = "refreshRate")]
    refresh_rate: f64,
    x: i32,
    y: i32,
    scale: f64,
    transform: i32,
    focused: bool,
    #[serde(rename = "dpmsStatus")]
    dpms_status: bool,
    disabled: bool,
    #[serde(rename = "availableModes")]
    available_modes: Vec<String>, // "3840x2160@143.99Hz"
}

fn parse_mode(s: &str) -> Option<MonitorMode> {
    // Format: "3840x2160@143.99Hz"  or  "3840x2160@143.998001Hz"
    let s = s.trim_end_matches("Hz");
    let (res, hz) = s.split_once('@')?;
    let (w, h) = res.split_once('x')?;
    Some(MonitorMode {
        width: w.parse().ok()?,
        height: h.parse().ok()?,
        refresh_rate: hz.parse().ok()?,
    })
}

impl DisplayBackend for HyprlandBackend {
    fn query_monitors(&self) -> Result<Vec<Monitor>, String> {
        let json = self.hyprctl(&["monitors", "-j"])?;
        let raw: Vec<HyprMonitor> =
            serde_json::from_str(&json).map_err(|e| format!("Failed to parse monitors JSON: {e}"))?;

        let monitors = raw
            .into_iter()
            .map(|m| {
                let available_modes: Vec<MonitorMode> =
                    m.available_modes.iter().filter_map(|s| parse_mode(s)).collect();

                Monitor {
                    id: m.id,
                    name: m.name,
                    description: m.description,
                    width: m.width,
                    height: m.height,
                    refresh_rate: m.refresh_rate,
                    x: m.x,
                    y: m.y,
                    scale: m.scale,
                    transform: m.transform,
                    enabled: !m.disabled,
                    dpms: m.dpms_status,
                    focused: m.focused,
                    available_modes,
                }
            })
            .collect();

        Ok(monitors)
    }

    fn apply(&self, configs: &[MonitorConfig]) -> Result<(), String> {
        let batch: String = configs
            .iter()
            .map(|c| {
                if !c.enabled {
                    format!("keyword monitor {},disable", c.name)
                } else {
                    format!(
                        "keyword monitor {},{}x{}@{:.2},{}x{},{:.2}",
                        c.name, c.width, c.height, c.refresh_rate, c.x, c.y, c.scale,
                    )
                }
            })
            .collect::<Vec<_>>()
            .join(";");

        // Use hyprctl --batch for atomic application
        self.hyprctl(&["--batch", &batch])?;
        Ok(())
    }

    fn persist(&self, configs: &[MonitorConfig]) -> Result<String, String> {
        let config_dir =
            dirs::config_dir().unwrap_or_else(|| std::path::PathBuf::from("~/.config"));
        let monitors_conf = config_dir.join("hypr").join("monitors.conf");

        let mut content = String::from(
            "# Generated by disp-center -- edit freely, re-running disp-center will overwrite.\n\n",
        );

        for c in configs {
            content.push_str(&c.to_hyprland_line());
            content.push('\n');
        }

        std::fs::write(&monitors_conf, &content)
            .map_err(|e| format!("Failed to write {}: {e}", monitors_conf.display()))?;

        Ok(monitors_conf.display().to_string())
    }

    fn set_primary(&self, monitor_name: &str) -> Result<(), String> {
        // In Hyprland, "primary" means workspace 1 lives there.
        self.hyprctl(&[
            "dispatch",
            "moveworkspacetomonitor",
            &format!("1 {monitor_name}"),
        ])?;
        Ok(())
    }

    fn identify(&self, monitors: &[crate::monitor::Monitor]) -> Result<(), String> {
        // Save the currently focused monitor so we can restore focus after
        let original_focus = monitors.iter().find(|m| m.focused).map(|m| m.name.clone());

        for (i, m) in monitors.iter().enumerate() {
            // Focus the target monitor so the notification appears on it
            let _ = self.hyprctl(&["dispatch", "focusmonitor", &m.name]);
            // Brief pause to let focus settle
            std::thread::sleep(std::time::Duration::from_millis(50));
            // Show a large notification with the monitor number and name
            let msg = format!("fontsize:40 {}  {}", i + 1, m.name);
            let _ = self.hyprctl(&["notify", "0", "2000", "rgb(89b4fa)", &msg]);
        }

        // Restore focus to the originally focused monitor
        if let Some(orig) = original_focus {
            std::thread::sleep(std::time::Duration::from_millis(50));
            let _ = self.hyprctl(&["dispatch", "focusmonitor", &orig]);
        }

        Ok(())
    }

    fn name(&self) -> &'static str {
        "Hyprland"
    }
}
